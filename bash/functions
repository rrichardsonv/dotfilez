# Function to get last N commands from bash history, insert them in a template, and copy to clipboard
# Usage: hist_to_template N
function hist_to_template() {
    # Check if an argument is provided
    if [ $# -ne 1 ] || ! [[ "$1" =~ ^[0-9]+$ ]]; then
        echo "Usage: hist_to_template N (where N is a positive integer)"
        return 1
    fi

    local num_commands="$1"
    
    # Get the last N commands from history, excluding this function call and related commands
    local history_commands=$(history | grep -v "hist_to_template" | tail -n "$num_commands" | awk '{$1=""; print substr($0,2)}')
    
    if [ -z "$history_commands" ]; then
        echo "No commands found in history or filter removed all commands"
        return 1
    fi
    
    local template;

    # Create the template with the commands
    read -r -d '' template <<EOF
create a bash function that performs the following commands
\`\`\`
$history_commands
\`\`\`
If you're aware of a more efficient way to perform one of the commands use that instead but comment above that replaced line with the original command
EOF;

# Copy to clipboard using pbcopy (macOS)
if command -v pbcopy > /dev/null; then
    echo "$template" | pbcopy
    echo "Template with last $num_commands commands copied to clipboard!"
else
    echo "Error: pbcopy command not found. Are you running on macOS?"
    echo "Here's your template:"
    echo "$template"
    return 1
fi

return 0;
}

# Function to replace lines in a file with a given string
# Usage: replace_lines "replacement text" file_path start_line [end_line]
function replace_lines() {
    # Check if required arguments are provided
    if [ $# -lt 3 ]; then
        echo "Usage: replace_lines \"replacement text\" file_path start_line [end_line]"
        return 1
    fi

    local replacement_text="$1"
    local file_path="$2"
    local start_line="$3"
    local end_line="${4:-$start_line}"  # If end_line is not provided, use start_line
    
    # Check if file exists
    if [ ! -f "$file_path" ]; then
        echo "Error: File '$file_path' does not exist"
        return 1
    fi
    
    # Check if line numbers are valid
    local file_length=$(wc -l < "$file_path")
    if ! [[ "$start_line" =~ ^[0-9]+$ ]] || ! [[ "$end_line" =~ ^[0-9]+$ ]]; then
        echo "Error: Line numbers must be integers"
        return 1
    fi
    
    if [ "$start_line" -le 0 ] || [ "$end_line" -le 0 ]; then
        echo "Error: Line numbers must be positive integers"
        return 1
    fi
    
    if [ "$start_line" -gt "$file_length" ]; then
        echo "Error: Start line ($start_line) exceeds file length ($file_length)"
        return 1
    fi
    
    if [ "$end_line" -lt "$start_line" ]; then
        echo "Error: End line ($end_line) cannot be less than start line ($start_line)"
        return 1
    fi
    
    # Create a temporary file
    local temp_file=$(mktemp)
    
    # Write the part before the replacement
    if [ "$start_line" -gt 1 ]; then
        head -n $((start_line - 1)) "$file_path" > "$temp_file"
    else
        # If replacing from the first line, create an empty temp file
        > "$temp_file"
    fi
    
    # Add the replacement text
    echo "$replacement_text" >> "$temp_file"
    
    # Append the part after the replacement if needed
    if [ "$end_line" -lt "$file_length" ]; then
        tail -n $((file_length - end_line)) "$file_path" >> "$temp_file"
    fi
    
    # Move the temporary file to the original location
    mv "$temp_file" "$file_path"
    
    echo "Successfully replaced lines $start_line to $end_line in '$file_path'"
    return 0
}


# Create a new directory and enter it
function md() {
  mkdir -p "$@" && cd "$@"
}

function cp_diff() {
  echo "git apply --ignore-whitespace << 'EOF'" > ./tmp-patch;
  git diff >> ./tmp-patch;
  echo "EOF" >> ./tmp-patch;
  pbcopy < ./tmp-patch;
  rm ./tmp-patch;
}

function npmlonk () {
  cd ../../../event-stream-client &&
  npm run prepack && \
  cd packages/client && \
  npm link && \
  cd ../../../cars_platform/apps/cars_web/assets && \
  npm link @carsdotcom/event-stream-client && \
  echo '-----------' && \
  npm ls @carsdotcom/event-stream-client && \
  echo '-----------' && \
  cd .. && \
  iex -S mix phx.server;
}

function server3 () {
  python3 -m http.server "${1:-8000}"
}

function salt_the_earth () {
  echo $(pwd)
  echo -e "$(tput setaf 4)$(tput setab 2)Have you closed VSCode and are running this command in a terminal window?\n Input the corresponding number to continue. $(tput sgr0)"
  select yn in "Yes" "No"; do
      case $yn in
          Yes ) broken_arrow; break;;
          No ) echo "Bye Felicia"; break;;
      esac
  done
}

function broken_arrow () {
  echo "$(tput setaf 4)$(tput setab 2)Deleting deps _build and .elixir_ls$(tput sgr0)"
  rm -rf deps _build .elixir_ls
  echo "$(tput setaf 4)$(tput setab 2)Getting your deps$(tput sgr0)"
  mix deps.get
  echo "$(tput setaf 4)$(tput setab 2)Starting elastic search...$(tput sgr0)"
  docker-compose up -d elasticsearch
  echo "$(tput setaf 4)$(tput setab 2)Running script/setup...$(tput sgr0)"
  # script/setup
}

function hand_turkey(){
  fswatch -r --event=Updated ./_build | sed -e 's/\/Users\/robertrichardson\/Repositories\/compilation_tester\/_build\/dev\/lib\/compilation_tester\///g;s/\.mix.+//g;sbin\/Elixir\.//g;s/\.beam//g;'
}

function tail_multiple(){
  osascript <<'EOF'
  tell application "iTerm"
      activate
      select first window

      # Create new tab
      tell current window
          create tab with default profile
      end tell

      # Split pane
      tell current session of current window
          split vertically with default profile
          split vertically with default profile
      end tell

      # Exec commands
      tell first session of current tab of current window
          write text "cd ~/Repositories/cars_platform"
          write text "tail_impressions \"beta-search\""
      end tell

      tell second session of current tab of current window
          write text "cd ~/Repositories/cars_platform"
          write text "tail_impressions \"beta-clicks\""
      end tell

      tell third session of current tab of current window
          write text "cd ~/Repositories/cars_platform"
          write text "tail_impressions \"beta-impressions\""
      end tell
    end tell
EOF
}

# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh
  else
    local arg=-sh
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@"
  else
    du $arg .[^.]* *
  fi
}

# Use Gitâ€™s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
  function diff() {
    git diff --no-index --color-words "$@"
  }
fi

# Create a data URL from a file
function dataurl() {
  local mimeType=$(file -b --mime-type "$1")
  if [[ $mimeType == text/* ]]; then
    mimeType="${mimeType};charset=utf-8"
  fi
  echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
  local port="${1:-8000}"
  sleep 1 && open "http://localhost:${port}/" &
  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
  # And serve everything as UTF-8 (although not technically correct, this doesnâ€™t break anything for binary files)
  python -c $'import http.server;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Add note to Notes.app (OS X 10.8)
# Usage: `note 'foo'` or `echo 'foo' | note`
function note() {
  local text
  if [ -t 0 ]; then # argument
    text="$1"
  else # pipe
    text=$(cat)
  fi
  body=$(echo "$text" | sed -E 's|$|<br>|g')
  osascript >/dev/null <<EOF
tell application "Notes"
  tell account "iCloud"
    tell folder "Notes"
      make new note with properties {name:"$text", body:"$body"}
    end tell
  end tell
end tell
EOF
}

# git mv files and associated test
function g_mv_lt(){
  local action="mv" rm_seg='' app_seg='' src=''
  local rpre="\033[0m\033[0;31m" gpre="\033[0m\033[0;32m" cpre="\033[0m\033[0;36m"
  local ipre="[ \033[00;34m..\033[0m ]" rst="\033[0m"

  if [ $# -eq 0 ]
  then
    action="help"
  fi;

  args=("$@")

  for ((i=0; i < $#; i++))
  do
    local arg="${args[$i]}"
    case $arg in
      --help)
        action="help"
        ;;
      --dry)
        action="dry"
        ;;
      +*)
        app_seg=$(echo $arg | sed -E 's/\/*$//' | sed -E 's/^\+/\//' | sed -e 's/\//\\\//g')
        ;;
      -*)
        rm_seg=$(echo $arg | sed -E 's/-//' | sed -E 's/\/*$//' | sed -e 's/\//\\\//g')
        ;;
      *)
        src="$arg"
        ;;
    esac
  done;

  local base_src=$(basename $src)
  local app_seg_pattern="s/\/$base_src/$app_seg\/$base_src/"
  local rm_seg_pattern="s/$rm_seg\///"
  local dst=$(echo $src | sed -E "$rm_seg_pattern" | sed -E "$app_seg_pattern");
  local tst_src=$(echo $src | sed -E 's/lib/test/' | sed -E 's/.ex/_test.exs/');
  local tst_dst=$(echo $dst | sed -E 's/lib/test/' | sed -E 's/.ex/_test.exs/');
  echo '';
  case $action in
    help)
      echo "usage: g_mv_lt [<options>] <source>";
      printf "example: ${cpre}g_mv_lt --dry -foo/bar +quux apps/baz/lib/foo/bar/quux.ex${rst}\n"
      echo '';
      printf "    -${rpre}<path/to/remove>${rst}        removes path/to/remove from source\n";
      printf "    +${gpre}<path/to/append>${rst}        appends path/to/append to source\n";
      echo "    --dry                    prints planned move for given args";
      echo "    --help                   displays this message";
      ;;

    dry)
      printf "${ipre} The command given will make the following changes\n";
      echo '';
      if [ ! -z "$rm_seg" ]
      then
        printf "${rpre} remove${rst} $(echo $rm_seg | sed -E 's/\\\//\//g')\n";
      fi;

      if [ ! -z "$app_seg" ]
      then
        printf "${gpre} append${rst} $(echo $app_seg | sed -E 's/\\\//\//g')\n";
      fi;
      echo ''
      printf "${ipre} This will perform the following move\n";
      echo "$src -> $dst";
      echo "$tst_src -> $tst_dst";
      ;;

    mv)
      echo "${ipre} Executing git mv";
      echo "$src -> $dst";
      git mv $src $dst;
      echo '';
      echo "$tst_src -> $tst_dst";
      git mv $tst_src $tst_dst;
      ;;
  esac;
  echo '';
  printf "\n[${gpre}done${rst}]\n";
}

function quickgres() {
  PGPASSWORD='postgres' psql -t \
    -h localhost \
    -U postgres \
    -d engine_dev \
    -c "$1"
}

function tail_kafka(){
  local imp_file="./apps/kafka_repo/priv/kafka_local/$1.json"
  if [ $# -eq 2 ]; then
    echo "Pulling out $2 values from tail..."
    local jq_pattern="{key: .key, payload: (.payload | fromjson | to_entries | map(select(.key | test(\"$2\") ) ) | from_entries)}"
  else
    local jq_pattern="{key: .key, payload: (.payload | fromjson | .)}"
  fi
  rm $imp_file
  touch -a $imp_file
  echo ""
  tail -f $imp_file | jq --sort-keys "$jq_pattern"
}

function mult_cmd(){
  function define(){ IFS='\n' read -r -d '' ${1} || true; }
  args=("$@")

  define screept <<'ENDSCREEPT'
  on run(argv)
    global termCmd
    set termCmd to convertListToString(argv, space)
    tell application "iTerm"
      activate

      # Create new tab
      tell current window
          create tab with default profile
      end tell

      # excute cmd
      tell current session of current window
          write text termCmd
      end tell
    end tell
  end run

  on convertListToString(theList, theDelimiter)
    set AppleScript's text item delimiters to theDelimiter
    set theString to theList as string
    set AppleScript's text item delimiters to ""
    return theString
  end convertListToString
ENDSCREEPT

  for ((i=0; i < $#; i++))
  do
    local arg="${args[$i]}"
    local dir="~/Repositories/cars_platform"
    case $arg in
      -cd=*)
        dir=$(echo $arg | sed -E 's/-cd=//')
        ;;
      *)
        osascript -e "$screept" "cd $dir " '&&' "$arg"
        ;;
    esac
  done;
}

function underscore_branch(){
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* [^\/]*\/\(.*\)/\1/;s/-/_/g';
}


function ecto_mig(){
  cp `ls apps/engine/priv/repo/migrations/ | tail -n 1 | sed -e 's/^/apps\/engine\/priv\/repo\/migrations\//'` "apps/engine/priv/repo/migrations/$(date +"%Y%m%d%H%M%S")_$(underscore_branch).exs"
}

function quickPronk () {
  local r="\360\237\244\226";
  local s="\342\234\205";
  local d="\360\237\221\213";

  printf "$r - Trimming input file..."
  echo "";
  # clip your mp4 file
  ffmpeg -ss 0 -i "$1" -t 15 -c copy ./trimmed_output.mp4

  printf "$s - Success."
  echo "";
  printf "$r - Getting rickroll.mp3..."
  echo "";
  # get rickroll
  curl --output rickroll.mp3 "https://www.myinstants.com/media/sounds/rick-rolled-meme-aetrim1602054550919.mp3"
  printf "$s - Success."

  # create tinysquare.page pixel
  echo 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2Pg92n8DwADJgHcfHlTZAAAAABJRU5ErkJggg==' | base64 --decode > ./tinysquare.png

  printf "$r - Preparing rickroll to prepend..."
  echo "";
  # convert rickroll to mp4, need image to trick codec
  ffmpeg -loop 1 -i ./tinysquare.png -i ./rickroll.mp3 -vf "scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:-1:-1:color=black,setsar=1,format=yuv420p" -shortest -fflags +shortest ./rickroll-vid.mp4

  # strip video stream from rickroll
  ffmpeg -i ./rickroll-vid.mp4 -vn -c:a copy ./rickroll-aud.mp4

  printf "$r - It's time to prepend ðŸŽ¶ ðŸŽµ..."
  echo "";
  # concat the rickroll to the original trimmed audio file MAINTAINING ITS ORIGINAL METADATA
  ffmpeg -i ./trimmed_output.mp4 -i ./rickroll-aud.mp4 -filter_complex "[0:a][1:a]concat=n=2:v=0:a=1[a]" -map "[a]" "$2"

  printf "$s - Success.\a"
  echo "";

  printf "$d - Cleaning up then done"
  echo "";
  # clean up files
  rm ./rickroll-vid.mp4 ./rickroll-aud.mp4 ./rickroll.mp3 ./trimmed_output.mp4 ./tinysquare.png
}


# god dang git
function goddangit () {
  local r="\360\237\244\226";
  local s="\342\234\205";
  local f="\342\233\224\357\270\217";
  local d="\360\237\221\213";
  printf " $r - Running rebase and push utility...\n"
  printf " $r - Checking working directory...\n"
  if [ -z "$(git status --porcelain)" ]; then
      OG_BRANCH=$(branch_name)
      ROOT_BRANCH=$(git remote show origin | grep 'HEAD branch' | sed 's/.*HEAD branch: //')
      printf " $s - Working directory clean.\n"
      echo "------------------------------------------"
      printf " $r - Rebasing onto latest origin/$ROOT_BRANCH...\n"
      git pull --rebase origin $ROOT_BRANCH
    if [ -z "$(git status --porcelain)" ]; then
      printf " $s - Rebase successful.\n"
      echo "------------------------------------------"
      printf " $r - Force pushing to update branch...\n"
      
      if ! git push origin $OG_BRANCH --no-verify --force-with-lease;
      then
        printf " $f - Push failed there may be additional output above\n"
        echo "------------------------------------------"
      else
        printf " $s - Push sucessful.\n"
        echo "------------------------------------------"
      fi
    else
      printf " $f - Not an easy rebase. Resolve your conflicts and run:\n"
      echo "------------------------------------------"
      echo git push origin $OG_BRANCH --no-verify --force-with-lease
      echo "------------------------------------------"
    fi
  else
    printf " $f - Cannot rebase when there are uncommited changes...\n"
    echo "------------------------------------------"
    echo "Sort out your mess first."
  fi

  printf " $d - Done.\n"
}

function git_prefix_branch () {
  local f="\342\233\224\357\270\217";
  local r="\360\237\244\226";
  local pat="/^[^*]/d;s/* /$1-/";
  local bronch_nm=$(git branch 2> /dev/null | sed -e "$pat")

  if [ -z "$(git status --porcelain)" ]; then
    printf " $r - Switching to $1 branch...\n";
    git co -b "$bronch_nm";
  else
    printf " $f - Clean up your mess you animal\n";
  fi
}


function npm_esc_prerelease () {
  local r="\360\237\244\226";
  local s="\342\234\205";
  local f="\342\233\224\357\270\217";
  local d="\360\237\221\213";

  printf " $r - Running npm prerelease utility...\n";
  printf " $r - Changing dir to event-stream-client...\n";
  cd ~/Repositories/event-stream-client;

  printf " $r - Checking working directory...\n";
  if [ -z "$(git status --porcelain)" ]; then
    printf " $s - All good\n";

    git_prefix_branch "prerelease"

    printf " $r - Creating client prerelease version...\n";
    cd packages/client
    npm version prerelease
    git add ../..
    git commit -m "prerelease for preview - 0"
    
    printf " $r - Running publish...\n";
    npm publish
  else
    printf " $f - Clean up your mess you animal\n";
  fi
}

function npm_esc_preview () {
  local r="\360\237\244\226";
  local s="\342\234\205";
  local f="\342\233\224\357\270\217";
  local d="\360\237\221\213";


  printf " $r - Changing dir to cars_web/assets...\n";
  cd ~/Repositories/cars_platform/apps/cars_web/assets;

  printf " $r - Checking working directory...\n";
  if [ -z "$(git status --porcelain)" ]; then
    printf " $s - All good\n";

    git_prefix_branch "preview";

    npm_bump "@carsdotcom/event-stream-client";

    cd ../../..;

    script/preview;
  else
    printf " $f - Clean up your mess you animal\n";
  fi
}

# Bump an npm package deterministically
function npm_bump () {
  local r="\360\237\244\226";
  local s="\342\234\205";
  local f="\342\233\224\357\270\217";
  local d="\360\237\221\213";
  printf " $r - Running npm update utility...\n";
  printf " $r - Checking working directory...\n";
  if [ -z "$(git status --porcelain)" ]; then
    printf " $s - All good\n";
    
    printf " $r - running npm uninstall $1...\n";
    npm uninstall "$1";
    
    printf " $r - running npm install $1...\n";
    npm install "$1";

    printf " $r - adding and committing package-lock and package.json...\n";
    git add ./package{,-lock}.json

    local new_version=$(npm ls "$1" | sed -E 's/[^0-9]+//;s/^[[:space:]]*//g;/^[[:space:]]*$/d');

    git commit -m "Bumps $1 to $new_version" --no-verify
  else
    printf " $f - Clean up your mess you animal\n";
  fi
}


function flaker () {
	RUNCOUNT=${1:-10};
  local r="\360\237\244\226";
  local d="\360\237\221\213";
  printf " $r - Running flaker utility\n";
	printf " $r - Set for ${RUNCOUNT} test runs...\n";
  for ((i=0; i < $1; i++))
  do
    printf " $r - run number: $i\n";
		mix test $2 || break
  done;
}
